<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Self-Driving Car Simulation</title>
    <style>
      body {
        margin: 0;
        background: #222;
        color: #eee;
        font-family: sans-serif;
      }
      #gameCanvas {
        display: block;
        margin: 0 auto;
        background: #444;
      }
      #controls {
        text-align: center;
        margin: 10px;
      }
      button {
        padding: 8px 12px;
        margin: 0 5px;
      }
    </style>
  </head>
  <body>
    <h2 style="text-align: center">Self-Driving Car Simulation</h2>
    <!-- Canvas doubled: 1200x800 -->
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="resetBtn">Reset</button>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      class Car {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.angle = 0;
          this.speed = 2;
          this.rays = [];
          this.rayCount = 5;
          this.rayLength = 100;
        }
        update(borders) {
          this._sense(borders);
          this._steer();
          let nextX = this.x + Math.cos(this.angle) * this.speed;
          let nextY = this.y + Math.sin(this.angle) * this.speed;
          const margin = 50;
          if (nextX < margin || nextX > canvas.width - margin) {
            this.angle = Math.PI - this.angle;
          }
          if (nextY < margin || nextY > canvas.height - margin) {
            this.angle = -this.angle;
          }
          this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;
        }
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          // red body
          ctx.fillStyle = "red";
          ctx.fillRect(-15, -7, 30, 14);
          // black wheels
          ctx.fillStyle = "black";
          const wheelW = 6,
            wheelH = 3;
          // front wheels
          ctx.fillRect(8, -9, wheelW, wheelH);
          ctx.fillRect(8, 6, wheelW, wheelH);
          // rear wheels
          ctx.fillRect(-14, -9, wheelW, wheelH);
          ctx.fillRect(-14, 6, wheelW, wheelH);
          ctx.restore();
          this._drawRays();
        }
        _sense(borders) {
          this.rays = [];
          const spread = Math.PI / 2;
          for (let i = 0; i < this.rayCount; i++) {
            const rayAng =
              this.angle + spread / 2 - (spread / (this.rayCount - 1)) * i;
            const start = { x: this.x, y: this.y };
            const end = {
              x: this.x + Math.cos(rayAng) * this.rayLength,
              y: this.y + Math.sin(rayAng) * this.rayLength,
            };
            let closest = null;
            for (let [A, B] of borders) {
              const pt = getIntersection(start, end, A, B);
              if (!pt) continue;
              const d = distance(start, pt);
              if (closest === null || d < closest.d) closest = { pt, d };
            }
            this.rays.push(closest ? closest.pt : end);
          }
        }
        _steer() {
          let minD = Infinity,
            minIdx = 0;
          this.rays.forEach((pt, i) => {
            const d = pt
              ? distance({ x: this.x, y: this.y }, pt)
              : this.rayLength;
            if (d < minD) {
              minD = d;
              minIdx = i;
            }
          });
          const mid = (this.rayCount - 1) / 2;
          this.angle += (minIdx - mid) * 0.005;
        }
        _drawRays() {
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 1;
          this.rays.forEach((pt) => {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(pt.x, pt.y);
            ctx.stroke();
          });
        }
      }

      const trackBorders = [];
      function buildBorders() {
        const m = 50;
        const pts = [
          { x: m, y: m },
          { x: canvas.width - m, y: m },
          { x: canvas.width - m, y: canvas.height - m },
          { x: m, y: canvas.height - m },
        ];
        trackBorders.length = 0;
        for (let i = 0; i < pts.length; i++)
          trackBorders.push([pts[i], pts[(i + 1) % pts.length]]);
      }

      function getIntersection(A, B, C, D) {
        const tTop = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);
        const uTop = (C.y - A.y) * (A.x - B.x) - (C.x - A.x) * (A.y - B.y);
        const bottom = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);
        if (!bottom) return null;
        const t = tTop / bottom,
          u = uTop / bottom;
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1)
          return { x: A.x + t * (B.x - A.x), y: A.y + t * (B.y - A.y) };
        return null;
      }
      function distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }

      let car, anim;
      function init() {
        buildBorders();
        // start car at quarter width, half height
        car = new Car(canvas.width * 0.25, canvas.height / 2);
      }
      function drawTrack() {
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        trackBorders.forEach(([A, B]) => {
          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        });
      }
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTrack();
        car.update(trackBorders);
        car.draw();
        anim = requestAnimationFrame(animate);
      }

      document.getElementById("startBtn").onclick = () => {
        cancelAnimationFrame(anim);
        animate();
      };
      document.getElementById("resetBtn").onclick = () => {
        cancelAnimationFrame(anim);
        init();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTrack();
        car.draw();
      };

      init();
      drawTrack();
      car.draw();
    </script>
  </body>
</html>
