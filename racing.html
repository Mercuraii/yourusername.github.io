<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Document metadata and responsive settings -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Self-Driving Car Simulation</title>
    <style>
      /* Page background and text styling */
      body {
        margin: 0;
        background: #222;
        color: #eee;
        font-family: sans-serif;
      }
      /* Center canvas and set its background */
      #gameCanvas {
        display: block;
        margin: 0 auto;
        background: #444;
      }
      /* Controls container styling */
      #controls {
        text-align: center;
        margin: 10px;
      }
      /* Button styling */
      button {
        padding: 8px 12px;
        margin: 0 5px;
      }
    </style>
  </head>
  <body>
    <!-- Page heading -->
    <h2 style="text-align: center">Self-Driving Car Simulation</h2>
    <!-- Canvas element where simulation is drawn -->
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    <!-- Start and Reset buttons -->
    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="resetBtn">Reset</button>
    </div>
    <script>
      // Get canvas and context
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Data arrays
      const trackBorders = [];
      const obstacles = [];
      const people = [];

      // Build track
      function buildBorders() {
        const m = 50;
        const pts = [
          { x: m, y: m },
          { x: canvas.width - m, y: m },
          { x: canvas.width - m, y: canvas.height - m },
          { x: m, y: canvas.height - m },
        ];
        trackBorders.length = 0;
        for (let i = 0; i < pts.length; i++)
          trackBorders.push([pts[i], pts[(i + 1) % pts.length]]);
      }

      // Define buildings (obstacles)
      function buildObstacles() {
        obstacles.length = 0;
        obstacles.push([
          { x: 400, y: 200 },
          { x: 550, y: 200 },
          { x: 550, y: 350 },
          { x: 400, y: 350 },
        ]);
        obstacles.push([
          { x: 700, y: 500 },
          { x: 850, y: 500 },
          { x: 850, y: 650 },
          { x: 700, y: 650 },
        ]);
      }

      // Define people
      function buildPeople() {
        people.length = 0;
        people.push({ x: 300, y: 600, r: 20 });
        people.push({ x: 900, y: 300, r: 20 });
      }

      // Draw track
      function drawTrack() {
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        trackBorders.forEach(([A, B]) => {
          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        });
      }

      // Draw buildings with windows
      function drawObstacles() {
        obstacles.forEach((poly) => {
          // Draw building block
          const x = poly[0].x;
          const y = poly[0].y;
          const w = poly[1].x - x;
          const h = poly[2].y - y;
          ctx.fillStyle = "#666";
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = "#444";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Draw windows
          const cols = 4;
          const rows = 5;
          const winW = w / (cols * 1.2);
          const winH = h / (rows * 1.2);
          const xOffset = (w - cols * winW) / (cols + 1);
          const yOffset = (h - rows * winH) / (rows + 1);
          ctx.fillStyle = "#ffd";
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              const wx = x + xOffset * (i + 1) + winW * i;
              const wy = y + yOffset * (j + 1) + winH * j;
              ctx.fillRect(wx, wy, winW, winH);
              ctx.strokeRect(wx, wy, winW, winH);
            }
          }
        });
      }

      // Draw people with eyes
      function drawPeople() {
        people.forEach((p) => {
          ctx.fillStyle = "#3cb371";
          ctx.beginPath();
          ctx.arc(p.x, p.y + 15, p.r, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = "#ffe4c4";
          ctx.beginPath();
          ctx.arc(p.x, p.y - 5, p.r / 2, 0, 2 * Math.PI);
          ctx.fill();
          const offX = p.r / 4,
            offY = p.r / 2,
            er = p.r / 8;
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(p.x - offX, p.y - 5 - offY, er, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(p.x + offX, p.y - 5 - offY, er, 0, 2 * Math.PI);
          ctx.fill();
        });
      }

      // Car class
      class Car {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.angle = 0;
          this.speed = 2;
          this.rayCount = 5;
          this.rayLength = 100;
          this.rays = [];
        }
        update() {
          const edges = trackBorders.concat(
            obstacles.flatMap((poly) =>
              poly.map((pt, i) => [pt, poly[(i + 1) % poly.length]])
            )
          );
          people.forEach((p) => {
            const pts = [
              { x: p.x - p.r, y: p.y - p.r },
              { x: p.x + p.r, y: p.y - p.r },
              { x: p.x + p.r, y: p.y + p.r },
              { x: p.x - p.r, y: p.y + p.r },
            ];
            pts.forEach((pt, i) => edges.push([pt, pts[(i + 1) % pts.length]]));
          });
          this._sense(edges);
          this._steer();
          let nx = this.x + Math.cos(this.angle) * this.speed,
            ny = this.y + Math.sin(this.angle) * this.speed;
          const m = 50;
          if (nx < m || nx > canvas.width - m)
            this.angle = Math.PI - this.angle;
          if (ny < m || ny > canvas.height - m) this.angle = -this.angle;
          this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;
        }
        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          ctx.fillStyle = "red";
          ctx.fillRect(-15, -7, 30, 14);
          ctx.fillStyle = "black";
          [
            [8, -9],
            [8, 6],
            [-14, -9],
            [-14, 6],
          ].forEach(([dx, dy]) => ctx.fillRect(dx, dy, 6, 3));
          ctx.restore();
          this._drawRays();
        }
        _sense(b) {
          this.rays = [];
          const s = Math.PI / 2;
          for (let i = 0; i < this.rayCount; i++) {
            const ang = this.angle + s / 2 - (s / (this.rayCount - 1)) * i;
            const st = { x: this.x, y: this.y };
            const en = {
              x: this.x + Math.cos(ang) * this.rayLength,
              y: this.y + Math.sin(ang) * this.rayLength,
            };
            let c = null;
            b.forEach(([A, B]) => {
              const t =
                ((D.x = C.x), 0) + (A.y - C.y) - (D.y - C.y) * (A.x - C.x)
                  ? null
                  : this;
            });
            this.rays.push(c ? c.pt : en);
          }
        }
        _steer() {
          let m = Infinity,
            idx = 0;
          this.rays.forEach((pt, i) => {
            const d = distance({ x: this.x, y: this.y }, pt);
            if (d < m) {
              m = d;
              idx = i;
            }
          });
          this.angle += (idx - (this.rayCount - 1) / 2) * 0.005;
        }
        _drawRays() {
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 1;
          this.rays.forEach((pt) => {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(pt.x, pt.y);
            ctx.stroke();
          });
        }
      }
      function getIntersection(A, B, C, D) {
        const tTop = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);
        const uTop = (C.y - A.y) * (A.x - B.x) - (C.x - A.x) * (A.y - B.y);
        const bot = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);
        if (!bot) return null;
        const t = tTop / bot,
          u = uTop / bot;
        return t >= 0 && t <= 1 && u >= 0 && u <= 1
          ? { x: A.x + t * (B.x - A.x), y: A.y + t * (B.y - A.y) }
          : null;
      }
      function distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      let car, anim;
      function init() {
        buildBorders();
        buildObstacles();
        buildPeople();
        car = new Car(canvas.width * 0.25, canvas.height / 2);
      }
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTrack();
        drawObstacles();
        drawPeople();
        car.update();
        car.draw();
        anim = requestAnimationFrame(animate);
      }
      document.getElementById("startBtn").onclick = () => {
        cancelAnimationFrame(anim);
        animate();
      };
      document.getElementById("resetBtn").onclick = () => {
        cancelAnimationFrame(anim);
        init();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawTrack();
        drawObstacles();
        drawPeople();
        car.draw();
      };
      init();
      drawTrack();
      drawObstacles();
      drawPeople();
      car.draw();
    </script>
  </body>
</html>
